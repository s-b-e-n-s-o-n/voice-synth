#!/usr/bin/env bash
#
# voice-synth - Interactive TUI for email data preparation pipeline
# All dependencies are automatically installed to ~/.cache/voice-synth/
#

set -e

# Directory for isolated venv and cache
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/voice-synth"
VENV_DIR="$CACHE_DIR/venv"
PYTHON="$VENV_DIR/bin/python3"
GUM_DIR="$CACHE_DIR/bin"
GUM="$GUM_DIR/gum"
GUM_VERSION="0.14.5"
JOBS_FILE="$CACHE_DIR/jobs.json"

# Get terminal width for centering
WIDTH=${COLUMNS:-80}

# Calculate left margin to center a given width
margin_for_width() {
    local item_width="${1:-40}"
    local margin=$(( (WIDTH - item_width) / 2 ))
    [ "$margin" -lt 0 ] && margin=0
    echo "$margin"
}

# Centered text helper
center() {
    "$GUM" style --width "$WIDTH" --align center "$@"
}

# Standard width for interactive elements
ITEM_WIDTH=50

# Get padding string for centering
get_padding() {
    local item_width="${1:-$ITEM_WIDTH}"
    local margin=$(( (WIDTH - item_width) / 2 ))
    [ "$margin" -lt 0 ] && margin=0
    printf '%*s' "$margin" ''
}

# Job tracking functions
init_jobs_file() {
    if [ ! -f "$JOBS_FILE" ]; then
        echo '[]' > "$JOBS_FILE"
    fi
}

# Add or update a job
save_job() {
    local mbox_path="$1"
    local work_dir="$2"
    local status="$3"  # in_progress, completed
    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    init_jobs_file

    # Use Python for JSON manipulation (jq not guaranteed)
    "$PYTHON" -c "
import json
import sys

mbox = '$mbox_path'
work_dir = '$work_dir'
status = '$status'
timestamp = '$timestamp'

with open('$JOBS_FILE', 'r') as f:
    jobs = json.load(f)

# Update existing or add new
found = False
for job in jobs:
    if job.get('mbox') == mbox and job.get('work_dir') == work_dir:
        job['status'] = status
        job['updated'] = timestamp
        found = True
        break

if not found:
    jobs.append({
        'mbox': mbox,
        'work_dir': work_dir,
        'status': status,
        'started': timestamp,
        'updated': timestamp
    })

# Keep only last 10 jobs
jobs = sorted(jobs, key=lambda x: x.get('updated', ''), reverse=True)[:10]

with open('$JOBS_FILE', 'w') as f:
    json.dump(jobs, f, indent=2)
"
}

# Get incomplete jobs as newline-separated "mbox|work_dir" pairs
get_incomplete_jobs() {
    init_jobs_file
    "$PYTHON" -c "
import json
import os

with open('$JOBS_FILE', 'r') as f:
    jobs = json.load(f)

for job in jobs:
    if job.get('status') == 'in_progress':
        work_dir = job.get('work_dir', '')
        # Check if work_dir still exists and has intermediate files
        if os.path.isdir(work_dir):
            has_intermediate = (
                os.path.exists(os.path.join(work_dir, 'emails_raw.json')) or
                os.path.exists(os.path.join(work_dir, 'emails.jsonl')) or
                os.path.exists(os.path.join(work_dir, 'cleaned_emails.json'))
            )
            # Skip if already completed
            if os.path.exists(os.path.join(work_dir, 'style_shortlist.csv')):
                continue
            if has_intermediate:
                mbox = job.get('mbox', 'unknown')
                # Show just filename, not full path
                mbox_name = os.path.basename(mbox)
                print(f'{mbox_name}|{work_dir}')
"
}

# Resolve which gum to use (system or cached)
resolve_gum() {
    if command -v gum &> /dev/null; then
        GUM="gum"
    elif [ -x "$GUM" ]; then
        : # Use cached version
    else
        GUM=""
    fi
}

# Download and install gum to cache directory
install_gum() {
    echo ""
    echo "╭─────────────────────────────────────────╮"
    echo "│  First-time setup: downloading tools... │"
    echo "╰─────────────────────────────────────────╯"
    echo ""
    mkdir -p "$GUM_DIR"

    local os arch url
    os="$(uname -s)"
    arch="$(uname -m)"

    case "$os" in
        Darwin) os="Darwin" ;;
        Linux)  os="Linux" ;;
        *)
            echo "Error: Unsupported OS: $os"
            echo "Please install gum manually: https://github.com/charmbracelet/gum"
            exit 1
            ;;
    esac

    case "$arch" in
        x86_64)  arch="x86_64" ;;
        aarch64|arm64) arch="arm64" ;;
        *)
            echo "Error: Unsupported architecture: $arch"
            echo "Please install gum manually: https://github.com/charmbracelet/gum"
            exit 1
            ;;
    esac

    url="https://github.com/charmbracelet/gum/releases/download/v${GUM_VERSION}/gum_${GUM_VERSION}_${os}_${arch}.tar.gz"

    echo "Downloading terminal UI..."
    curl -# -L "$url" | tar xz -C "$GUM_DIR" gum

    chmod +x "$GUM"
    echo "✓ Terminal UI ready"
    echo ""
}

# Check for gum, install if missing
check_gum() {
    resolve_gum
    if [ -z "$GUM" ]; then
        install_gum
        GUM="$GUM_DIR/gum"
    fi
}

# Ensure venv exists, create if needed
ensure_venv() {
    if [ ! -d "$VENV_DIR" ]; then
        mkdir -p "$CACHE_DIR"
        echo "Creating virtual environment in $VENV_DIR..."
        python3 -m venv "$VENV_DIR"
        # Upgrade pip in the new venv
        "$PYTHON" -m pip install --upgrade pip --quiet
    fi
}

# Check Python dependencies (in the isolated venv)
check_deps() {
    # Venv must exist first
    if [ ! -f "$PYTHON" ]; then
        return 1
    fi

    local missing=()

    if ! "$PYTHON" -c "import ijson" 2>/dev/null; then
        missing+=("ijson")
    fi
    if ! "$PYTHON" -c "import presidio_analyzer" 2>/dev/null; then
        missing+=("presidio-analyzer presidio-anonymizer")
    fi
    if ! "$PYTHON" -c "import spacy; spacy.load('en_core_web_lg')" 2>/dev/null; then
        missing+=("spacy model (en_core_web_lg)")
    fi

    if [ ${#missing[@]} -gt 0 ]; then
        return 1
    fi
    return 0
}

# Header
show_header() {
    clear
    echo ""
    "$GUM" style \
        --border double \
        --border-foreground 99 \
        --padding "1 4" \
        --margin "1 0 1 0" \
        --align center \
        --width "$WIDTH" \
        "$("$GUM" style --foreground 99 --bold 'Voice Synthesizer')" \
        "$("$GUM" style --foreground 245 'Email data preparation for GPT fine-tuning')"
    echo ""
}

# Setup wizard - creates isolated venv and installs dependencies
setup_deps() {
    show_header

    # Check if everything is already set up
    if check_deps; then
        return 0
    fi

    # First-time setup - auto-install everything
    center "$("$GUM" style --foreground 99 --bold 'First-time setup')"
    echo ""
    center "$("$GUM" style --foreground 245 'Installing required components...')"
    center "$("$GUM" style --foreground 245 --italic 'This only happens once.')"
    echo ""

    # Create venv if needed
    if [ ! -d "$VENV_DIR" ]; then
        "$GUM" spin --spinner dot --title "Creating Python environment..." -- \
            bash -c "mkdir -p '$CACHE_DIR' && python3 -m venv '$VENV_DIR' && '$PYTHON' -m pip install --upgrade pip --quiet"
        echo "  $("$GUM" style --foreground 82 '✓') Python environment"
    else
        echo "  $("$GUM" style --foreground 82 '✓') Python environment"
    fi

    # Install Python packages one by one, skipping if already installed
    if "$PYTHON" -c "import ijson" 2>/dev/null; then
        echo "  $("$GUM" style --foreground 82 '✓') ijson (JSON parser)"
    else
        "$GUM" spin --spinner dot --title "Installing ijson..." -- \
            "$PYTHON" -m pip install ijson --quiet
        echo "  $("$GUM" style --foreground 82 '✓') ijson (JSON parser)"
    fi

    if "$PYTHON" -c "import spacy" 2>/dev/null; then
        echo "  $("$GUM" style --foreground 82 '✓') spaCy (language processing)"
    else
        "$GUM" spin --spinner dot --title "Installing spaCy..." -- \
            "$PYTHON" -m pip install spacy --quiet
        echo "  $("$GUM" style --foreground 82 '✓') spaCy (language processing)"
    fi

    if "$PYTHON" -c "import presidio_analyzer" 2>/dev/null; then
        echo "  $("$GUM" style --foreground 82 '✓') Presidio (privacy protection)"
    else
        "$GUM" spin --spinner dot --title "Installing Presidio..." -- \
            "$PYTHON" -m pip install presidio-analyzer presidio-anonymizer --quiet
        echo "  $("$GUM" style --foreground 82 '✓') Presidio (privacy protection)"
    fi

    # Download spaCy model if needed
    if "$PYTHON" -c "import spacy; spacy.load('en_core_web_lg')" 2>/dev/null; then
        echo "  $("$GUM" style --foreground 82 '✓') Language model (en_core_web_lg)"
    else
        "$GUM" spin --spinner dot --title "Downloading language model (~1 min)..." -- \
            "$PYTHON" -m spacy download en_core_web_lg --quiet
        echo "  $("$GUM" style --foreground 82 '✓') Language model (en_core_web_lg)"
    fi

    echo ""
    center "$("$GUM" style --foreground 82 --bold '✓ Setup complete!')"
    sleep 1
}

# File picker with drag-and-drop support
pick_file() {
    local prompt="$1"
    local pattern="${2:-*.json}"

    center "$("$GUM" style --foreground 245 "$prompt")"
    echo ""

    local pad
    pad=$(get_padding $ITEM_WIDTH)

    # Ask how they want to select
    local method
    method=$("$GUM" choose \
        "${pad}Drag & drop file here (or paste path)" \
        "${pad}Browse for file")
    method="${method#"$pad"}"

    echo ""

    if [[ "$method" == "Drag"* ]]; then
        # Drag and drop / paste path mode
        center "$("$GUM" style --foreground 245 --italic 'Drag file here or paste path, then press Enter:')"
        local path
        printf '%s' "$pad"
        path=$("$GUM" input --placeholder "Drop file here..." --width 60)
        # Clean up path (remove quotes, escaped spaces, trailing spaces)
        path="${path//\'/}"
        path="${path//\"/}"
        path="${path//\\ / }"  # unescape spaces
        path="${path%% }"
        path="${path## }"      # trim leading space
        echo "$path"
    else
        # Browse mode - find matching files
        local files
        files=$(find . -maxdepth 3 -name "$pattern" -type f 2>/dev/null | head -30)

        if [ -n "$files" ]; then
            printf '%s' "$pad"
            echo "$files" | "$GUM" filter --placeholder "Type to search..." --width 60
        else
            center "$("$GUM" style --foreground 214 "No $pattern files found in current directory.")"
            center "$("$GUM" style --foreground 245 --italic 'Enter path manually:')"
            printf '%s' "$pad"
            "$GUM" input --placeholder "Enter file path..." --width 60
        fi
    fi
}

# Get sender email
get_sender() {
    center "$("$GUM" style --foreground 245 'Filter to emails from a specific sender?')"
    echo ""

    local pad
    pad=$(get_padding $ITEM_WIDTH)

    local choice
    choice=$("$GUM" choose "${pad}Yes, filter by sender" "${pad}No, keep all senders")
    choice="${choice#"$pad"}"

    if [[ "$choice" == "Yes"* ]]; then
        echo ""
        printf '%s' "$pad"
        "$GUM" input --placeholder "Enter sender email (e.g., user@example.com)" --width 50
    else
        echo ""
    fi
}

# Run import MBOX stage
run_import() {
    show_header
    center "$("$GUM" style --foreground 99 --bold 'Step 0: Import MBOX (Google Takeout)')"
    echo ""
    center "$("$GUM" style --foreground 245 'This converts an MBOX file from Google Takeout to JSON,')"
    center "$("$GUM" style --foreground 245 'stripping attachments and keeping only text content.')"
    echo ""

    local input_file
    input_file=$(pick_file "Select MBOX file:" "*.mbox")

    local pad
    pad=$(get_padding $ITEM_WIDTH)

    if [ -z "$input_file" ] || [ ! -f "$input_file" ]; then
        echo ""
        center "$("$GUM" style --foreground 196 "File not found: $input_file")"
        printf '%s' "$pad"
        "$GUM" input --placeholder "Press Enter to continue..."
        return 1
    fi

    local output_file="${input_file%.mbox}.json"
    echo ""
    center "$("$GUM" style --foreground 245 "Output: $output_file")"
    echo ""
    center "$("$GUM" style --foreground 214 'This may take a while for large mailboxes...')"
    echo ""

    "$PYTHON" pipeline.py import "$input_file" --out "$output_file"

    echo ""
    center "$("$GUM" style --foreground 82 "Done! Created: $output_file")"
    printf '%s' "$pad"
    "$GUM" input --placeholder "Press Enter to continue..."
}

# Run convert stage
run_convert() {
    show_header
    center "$("$GUM" style --foreground 99 --bold 'Step 1: Convert to JSONL')"
    echo ""

    local input_file
    input_file=$(pick_file "Select input JSON file:" "*.json")

    local pad
    pad=$(get_padding $ITEM_WIDTH)

    if [ -z "$input_file" ] || [ ! -f "$input_file" ]; then
        echo ""
        center "$("$GUM" style --foreground 196 "File not found: $input_file")"
        printf '%s' "$pad"
        "$GUM" input --placeholder "Press Enter to continue..."
        return 1
    fi

    local output_file="${input_file%.json}.jsonl"
    echo ""
    center "$("$GUM" style --foreground 245 "Output: $output_file")"
    echo ""

    "$GUM" spin --spinner dot --title "Converting and stripping attachments..." -- \
        "$PYTHON" pipeline.py convert "$input_file" --out "$output_file"

    center "$("$GUM" style --foreground 82 "Done! Created: $output_file")"
    printf '%s' "$pad"
    "$GUM" input --placeholder "Press Enter to continue..."
}

# Run clean stage
run_clean() {
    show_header
    center "$("$GUM" style --foreground 99 --bold 'Step 2: Clean & Anonymize')"
    echo ""

    local input_file
    input_file=$(pick_file "Select input file:" "*.json*")

    local pad
    pad=$(get_padding $ITEM_WIDTH)

    if [ -z "$input_file" ] || [ ! -f "$input_file" ]; then
        echo ""
        center "$("$GUM" style --foreground 196 "File not found: $input_file")"
        printf '%s' "$pad"
        "$GUM" input --placeholder "Press Enter to continue..."
        return 1
    fi

    local sender
    sender=$(get_sender)

    local sender_arg=""
    if [ -n "$sender" ]; then
        sender_arg="--sender $sender"
    fi

    local output_file="cleaned_emails.json"
    echo ""
    center "$("$GUM" style --foreground 245 "Output: $output_file")"
    echo ""
    center "$("$GUM" style --foreground 214 'This may take a while for large files...')"
    echo ""

    # Run with visible output
    "$PYTHON" pipeline.py clean "$input_file" --out "$output_file" $sender_arg

    echo ""
    center "$("$GUM" style --foreground 82 "Done! Created: $output_file")"
    printf '%s' "$pad"
    "$GUM" input --placeholder "Press Enter to continue..."
}

# Run curate stage
run_curate() {
    show_header
    center "$("$GUM" style --foreground 99 --bold 'Step 3: Curate Shortlist')"
    echo ""

    local input_file
    input_file=$(pick_file "Select cleaned emails JSON:" "*cleaned*.json")

    local pad
    pad=$(get_padding $ITEM_WIDTH)

    if [ -z "$input_file" ] || [ ! -f "$input_file" ]; then
        echo ""
        center "$("$GUM" style --foreground 196 "File not found: $input_file")"
        printf '%s' "$pad"
        "$GUM" input --placeholder "Press Enter to continue..."
        return 1
    fi

    echo ""
    center "$("$GUM" style --foreground 245 'Max emails per topic:')"
    printf '%s' "$pad"
    local per_topic
    per_topic=$("$GUM" input --value "200" --placeholder "200" --width 20)
    per_topic="${per_topic:-200}"

    local output_file="style_shortlist.csv"
    echo ""
    center "$("$GUM" style --foreground 245 "Output: $output_file")"
    echo ""

    "$PYTHON" pipeline.py curate "$input_file" --out "$output_file" --per-topic "$per_topic"

    echo ""
    center "$("$GUM" style --foreground 82 "Done! Created: $output_file")"
    center "$("$GUM" style --foreground 245 'Open in a spreadsheet to review and annotate.')"
    printf '%s' "$pad"
    "$GUM" input --placeholder "Press Enter to continue..."
}

# Run full pipeline
# Simple get started - just file and sender, use defaults
run_full_pipeline() {
    show_header
    center "$("$GUM" style --foreground 99 --bold 'Get Started')"
    echo ""

    local pad
    pad=$(get_padding $ITEM_WIDTH)

    local input_file
    input_file=$(pick_file "Drop your .mbox file from Google Takeout:" "*.mbox")

    if [ -z "$input_file" ] || [ ! -f "$input_file" ]; then
        echo ""
        center "$("$GUM" style --foreground 196 "File not found: $input_file")"
        printf '%s' "$pad"
        "$GUM" input --placeholder "Press Enter to continue..."
        return 1
    fi

    local sender
    sender=$(get_sender)

    local sender_arg=""
    if [ -n "$sender" ]; then
        sender_arg="--sender $sender"
    fi

    echo ""
    center "$("$GUM" style --foreground 214 'Processing your emails...')"
    center "$("$GUM" style --foreground 245 --italic 'This may take a few minutes for large mailboxes.')"
    echo ""

    # Track job as in_progress
    local work_dir
    work_dir=$(pwd)
    local abs_input
    abs_input=$(cd "$(dirname "$input_file")" && pwd)/$(basename "$input_file")
    save_job "$abs_input" "$work_dir" "in_progress"

    "$PYTHON" pipeline.py run "$input_file" $sender_arg

    # Mark job as completed
    save_job "$abs_input" "$work_dir" "completed"

    # Copy CSV to Desktop
    local desktop_path="$HOME/Desktop/style_shortlist.csv"
    cp style_shortlist.csv "$desktop_path" 2>/dev/null || true

    echo ""
    center "$("$GUM" style --foreground 82 --bold 'Done!')"
    echo ""
    center "$("$GUM" style --foreground 82 --bold 'Output saved to Desktop:')"
    center "$("$GUM" style --foreground 82 '~/Desktop/style_shortlist.csv')"
    echo ""
    center "$("$GUM" style --foreground 245 --italic 'Open it in a spreadsheet to review your emails.')"
    echo ""
    printf '%s' "$pad"
    "$GUM" input --placeholder "Press Enter to continue..."
}

# Advanced get started - walks through all settings with explanations
run_full_pipeline_advanced() {
    show_header
    center "$("$GUM" style --foreground 99 --bold 'Get Started (Advanced)')"
    echo ""
    center "$("$GUM" style --foreground 245 "Let's configure your email processing.")"
    echo ""

    local pad
    pad=$(get_padding $ITEM_WIDTH)

    # Step 1: File selection
    center "$("$GUM" style --foreground 99 --bold 'Step 1: Select your email file')"
    echo ""
    local input_file
    input_file=$(pick_file "Drop your .mbox file from Google Takeout:" "*.mbox")

    if [ -z "$input_file" ] || [ ! -f "$input_file" ]; then
        echo ""
        center "$("$GUM" style --foreground 196 "File not found: $input_file")"
        printf '%s' "$pad"
        "$GUM" input --placeholder "Press Enter to continue..."
        return 1
    fi

    # Step 2: Sender filter
    show_header
    center "$("$GUM" style --foreground 99 --bold 'Step 2: Filter by sender')"
    echo ""
    center "$("$GUM" style --foreground 245 'To train a model on YOUR writing style, we need')"
    center "$("$GUM" style --foreground 245 'only emails that YOU wrote (not received).')"
    echo ""
    local sender
    sender=$(get_sender)

    local sender_arg=""
    if [ -n "$sender" ]; then
        sender_arg="--sender $sender"
    fi

    # Step 3: Date range
    show_header
    center "$("$GUM" style --foreground 99 --bold 'Step 3: Date range')"
    echo ""
    center "$("$GUM" style --foreground 245 'How many years back should we look?')"
    center "$("$GUM" style --foreground 245 --italic 'Older emails may not reflect your current writing style.')"
    echo ""
    printf '%s' "$pad"
    local years
    years=$("$GUM" input --value "5" --placeholder "5" --width 20)
    years="${years:-5}"

    # Step 4: Emails per topic
    show_header
    center "$("$GUM" style --foreground 99 --bold 'Step 4: Emails per category')"
    echo ""
    center "$("$GUM" style --foreground 245 'Max emails to keep per topic (client, strategy, etc.)')"
    center "$("$GUM" style --foreground 245 --italic 'This ensures balanced training data across different types.')"
    echo ""
    printf '%s' "$pad"
    local per_topic
    per_topic=$("$GUM" input --value "200" --placeholder "200" --width 20)
    per_topic="${per_topic:-200}"

    # Step 5: Minimum length
    show_header
    center "$("$GUM" style --foreground 99 --bold 'Step 5: Minimum email length')"
    echo ""
    center "$("$GUM" style --foreground 245 'Minimum characters for an email to be included.')"
    center "$("$GUM" style --foreground 245 --italic 'Short emails like "Thanks!" don'\''t capture your style well.')"
    echo ""
    printf '%s' "$pad"
    local min_chars
    min_chars=$("$GUM" input --value "200" --placeholder "200" --width 20)
    min_chars="${min_chars:-200}"

    # Step 6: Dedupe threshold
    show_header
    center "$("$GUM" style --foreground 99 --bold 'Step 6: Duplicate detection')"
    echo ""
    center "$("$GUM" style --foreground 245 'How similar should two emails be to count as duplicates?')"
    center "$("$GUM" style --foreground 245 --italic '0.8 = 80% similar. Higher = stricter, fewer removed.')"
    echo ""
    printf '%s' "$pad"
    local dedupe_threshold
    dedupe_threshold=$("$GUM" input --value "0.8" --placeholder "0.8" --width 20)
    dedupe_threshold="${dedupe_threshold:-0.8}"

    # Run pipeline
    show_header
    center "$("$GUM" style --foreground 214 'Processing your emails...')"
    center "$("$GUM" style --foreground 245 --italic 'This may take a few minutes for large mailboxes.')"
    echo ""

    # Track job as in_progress
    local work_dir
    work_dir=$(pwd)
    local abs_input
    abs_input=$(cd "$(dirname "$input_file")" && pwd)/$(basename "$input_file")
    save_job "$abs_input" "$work_dir" "in_progress"

    # Run import if mbox
    "$PYTHON" pipeline.py import "$input_file" --out emails_raw.json
    "$PYTHON" pipeline.py convert emails_raw.json --out emails.jsonl
    "$PYTHON" pipeline.py clean emails.jsonl --out cleaned_emails.json $sender_arg --years "$years"
    "$PYTHON" pipeline.py curate cleaned_emails.json --out style_shortlist.csv --per-topic "$per_topic" --min-chars "$min_chars" --dedupe-threshold "$dedupe_threshold"

    # Mark job as completed
    save_job "$abs_input" "$work_dir" "completed"

    # Copy CSV to Desktop
    local desktop_path="$HOME/Desktop/style_shortlist.csv"
    cp style_shortlist.csv "$desktop_path" 2>/dev/null || true

    echo ""
    center "$("$GUM" style --foreground 82 --bold 'Done!')"
    echo ""
    center "$("$GUM" style --foreground 82 --bold 'Output saved to Desktop:')"
    center "$("$GUM" style --foreground 82 '~/Desktop/style_shortlist.csv')"
    echo ""
    center "$("$GUM" style --foreground 245 --italic 'Open it in a spreadsheet to review your emails.')"
    echo ""
    printf '%s' "$pad"
    "$GUM" input --placeholder "Press Enter to continue..."
}

# Show help
show_help() {
    show_header
    center "$("$GUM" style --foreground 99 --bold 'Help')"
    echo ""

    "$GUM" style --width "$WIDTH" --align left --padding "0 4" << 'EOF'
Voice Synthesizer prepares email data for fine-tuning GPT models.

PIPELINE STAGES:

  0. Import     Import MBOX file from Google Takeout
                Strips attachments, extracts text content

  1. Convert    Convert JSON array to JSONL format
                Strips remaining attachments and unsafe fields

  2. Clean      Filter and anonymize emails
                Uses Microsoft Presidio for PII detection
                Removes signatures, quoted replies

  3. Curate     Build a shortlist of best samples
                Groups by topic, scores by richness
                Outputs CSV for manual review

TYPICAL WORKFLOW:

  1. Download your emails via Google Takeout (select MBOX format)
  2. Run "Full Pipeline" and select your .mbox file
  3. Enter your email address to filter to emails you sent
  4. Review the CSV shortlist in a spreadsheet
  5. Use selected samples for fine-tuning

REQUIREMENTS:

  - Python 3.8+
  - gum (for this TUI)

INSTALLATION:

  Python dependencies are automatically installed to an isolated
  virtual environment at ~/.cache/voice-synth/venv

  To reset the environment, delete the directory and restart.
EOF

    echo ""
    local pad
    pad=$(get_padding $ITEM_WIDTH)
    printf '%s' "$pad"
    "$GUM" input --placeholder "Press Enter to continue..."
}

# Uninstall/cleanup
run_cleanup() {
    show_header
    center "$("$GUM" style --foreground 99 --bold 'Uninstall')"
    echo ""
    center "$("$GUM" style --foreground 245 'This will delete all downloaded tools and dependencies.')"
    center "$("$GUM" style --foreground 245 --italic "$CACHE_DIR")"
    echo ""

    local pad
    pad=$(get_padding 40)
    printf '%s' "$pad"
    if "$GUM" confirm "Delete everything and uninstall?"; then
        echo ""
        "$GUM" spin --spinner dot --title "Removing installed files..." -- \
            rm -rf "$CACHE_DIR"
        echo ""
        center "$("$GUM" style --foreground 82 '✓ Uninstalled successfully')"
        echo ""
        center "$("$GUM" style --foreground 245 'Run ./voice-synth again to reinstall.')"
        echo ""
        exit 0
    fi
}

# Show results when already processed
show_results() {
    show_header
    center "$("$GUM" style --foreground 82 --bold 'Processing Complete!')"
    echo ""

    local pad
    pad=$(get_padding $ITEM_WIDTH)

    # Copy to Desktop if not already there
    local desktop_path="$HOME/Desktop/style_shortlist.csv"
    if [ -f "style_shortlist.csv" ]; then
        cp style_shortlist.csv "$desktop_path" 2>/dev/null || true
    fi

    center "$("$GUM" style --foreground 82 --bold 'Output saved to Desktop:')"
    center "$("$GUM" style --foreground 82 '~/Desktop/style_shortlist.csv')"
    echo ""
    center "$("$GUM" style --foreground 245 --italic 'Open it in a spreadsheet to review your emails.')"
    echo ""
    printf '%s' "$pad"
    "$GUM" input --placeholder "Press Enter to continue..."
}

# Resume from intermediate files
run_resume() {
    show_header
    local pad
    pad=$(get_padding $ITEM_WIDTH)

    # Determine where to resume from
    local start_stage=""
    local input_file=""

    if [ -f "cleaned_emails.json" ]; then
        start_stage="curate"
        input_file="cleaned_emails.json"
        center "$("$GUM" style --foreground 99 --bold 'Resuming from Step 3: Curate')"
    elif [ -f "emails.jsonl" ]; then
        start_stage="clean"
        input_file="emails.jsonl"
        center "$("$GUM" style --foreground 99 --bold 'Resuming from Step 2: Clean')"
    elif [ -f "emails_raw.json" ]; then
        start_stage="convert"
        input_file="emails_raw.json"
        center "$("$GUM" style --foreground 99 --bold 'Resuming from Step 1: Convert')"
    fi

    echo ""
    center "$("$GUM" style --foreground 245 "Found: $input_file")"
    echo ""

    # Get sender if we're at clean stage
    local sender=""
    local sender_arg=""
    if [ "$start_stage" = "clean" ]; then
        sender=$(get_sender)
        if [ -n "$sender" ]; then
            sender_arg="--sender $sender"
        fi
    fi

    echo ""
    center "$("$GUM" style --foreground 214 'Running pipeline...')"
    echo ""

    case "$start_stage" in
        "convert")
            "$PYTHON" pipeline.py convert "$input_file" --out emails.jsonl
            sender=$(get_sender)
            if [ -n "$sender" ]; then
                sender_arg="--sender $sender"
            fi
            "$PYTHON" pipeline.py clean emails.jsonl --out cleaned_emails.json $sender_arg
            "$PYTHON" pipeline.py curate cleaned_emails.json --out style_shortlist.csv
            ;;
        "clean")
            "$PYTHON" pipeline.py clean "$input_file" --out cleaned_emails.json $sender_arg
            "$PYTHON" pipeline.py curate cleaned_emails.json --out style_shortlist.csv
            ;;
        "curate")
            "$PYTHON" pipeline.py curate "$input_file" --out style_shortlist.csv
            ;;
    esac

    # Mark any job for this directory as completed
    local work_dir
    work_dir=$(pwd)
    "$PYTHON" -c "
import json
import os

jobs_file = '$JOBS_FILE'
work_dir = '$work_dir'

if os.path.exists(jobs_file):
    with open(jobs_file, 'r') as f:
        jobs = json.load(f)
    for job in jobs:
        if job.get('work_dir') == work_dir:
            job['status'] = 'completed'
    with open(jobs_file, 'w') as f:
        json.dump(jobs, f, indent=2)
" 2>/dev/null || true

    # Copy CSV to Desktop
    local desktop_path="$HOME/Desktop/style_shortlist.csv"
    cp style_shortlist.csv "$desktop_path" 2>/dev/null || true

    echo ""
    center "$("$GUM" style --foreground 82 --bold 'Pipeline complete!')"
    echo ""
    center "$("$GUM" style --foreground 82 --bold 'Output saved to Desktop:')"
    center "$("$GUM" style --foreground 82 '~/Desktop/style_shortlist.csv')"
    echo ""
    center "$("$GUM" style --foreground 245 --italic 'Open it in a spreadsheet to review your emails.')"
    echo ""
    printf '%s' "$pad"
    "$GUM" input --placeholder "Press Enter to continue..."
}

# Resume a job from a specific work directory
resume_job_in_dir() {
    local work_dir="$1"
    cd "$work_dir" || return 1
    run_resume
}

# Main menu
main_menu() {
    while true; do
        show_header

        local margin
        margin=$(margin_for_width $ITEM_WIDTH)
        local padding
        padding=$(printf '%*s' "$margin" '')

        # Build menu options
        local -a menu_options=()

        # Check for incomplete jobs from tracker
        local incomplete_jobs
        incomplete_jobs=$(get_incomplete_jobs 2>/dev/null || echo "")

        if [ -n "$incomplete_jobs" ]; then
            menu_options+=("${padding}Continue previous")
        fi

        menu_options+=("${padding}Get started")
        menu_options+=("${padding}Get started (advanced)")
        menu_options+=("${padding}Help")
        menu_options+=("${padding}Uninstall")
        menu_options+=("${padding}Quit")

        local choice
        choice=$("$GUM" choose "${menu_options[@]}")
        # Strip padding from result
        choice="${choice#"$padding"}"

        case "$choice" in
            "Continue previous")
                # Get the most recent incomplete job
                local target_dir
                target_dir=$(echo "$incomplete_jobs" | head -1 | cut -d'|' -f2)

                if [ -n "$target_dir" ] && [ -d "$target_dir" ]; then
                    resume_job_in_dir "$target_dir"
                else
                    center "$("$GUM" style --foreground 196 'Previous session not found')"
                    sleep 1
                fi
                ;;
            "Get started")
                run_full_pipeline
                ;;
            "Get started (advanced)")
                run_full_pipeline_advanced
                ;;
            "Help")
                show_help
                ;;
            "Uninstall")
                run_cleanup
                ;;
            "Quit")
                center "$("$GUM" style --foreground 245 'Goodbye!')"
                exit 0
                ;;
        esac
    done
}

# Ensure venv is ready for CLI usage (silent unless missing deps)
ensure_venv_cli() {
    if [ ! -d "$VENV_DIR" ]; then
        echo "Setting up isolated environment in $VENV_DIR..."
        mkdir -p "$CACHE_DIR"
        python3 -m venv "$VENV_DIR"
        "$PYTHON" -m pip install --upgrade pip --quiet
    fi

    if ! check_deps; then
        echo "Installing dependencies..."
        "$PYTHON" -m pip install ijson presidio-analyzer presidio-anonymizer spacy --quiet
        "$PYTHON" -m spacy download en_core_web_lg --quiet
    fi
}

# Entry point
main() {
    check_gum

    # If arguments provided, pass to pipeline.py directly
    if [ $# -gt 0 ]; then
        ensure_venv_cli
        "$PYTHON" pipeline.py "$@"
        exit $?
    fi

    # Otherwise, show TUI
    setup_deps
    main_menu
}

main "$@"
